// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sugiyama_layout_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SugiyamaLayoutConfig _$SugiyamaLayoutConfigFromJson(Map<String, dynamic> json) {
  return _SugiyamaLayoutConfig.fromJson(json);
}

/// @nodoc
mixin _$SugiyamaLayoutConfig {
  double get groupHorizontalPadding => throw _privateConstructorUsedError;
  double get groupVerticalPadding => throw _privateConstructorUsedError;
  double get nodeMarginX => throw _privateConstructorUsedError;
  double get nodeMarginY => throw _privateConstructorUsedError;
  String get rankDir => throw _privateConstructorUsedError;
  String get ranker => throw _privateConstructorUsedError;
  @SizeConverter()
  Size get emptyGroupSize => throw _privateConstructorUsedError;
  bool get compactTop => throw _privateConstructorUsedError;
  bool get compactBottom => throw _privateConstructorUsedError;
  bool get compactLeft => throw _privateConstructorUsedError;
  bool get compactRight => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SugiyamaLayoutConfigCopyWith<SugiyamaLayoutConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SugiyamaLayoutConfigCopyWith<$Res> {
  factory $SugiyamaLayoutConfigCopyWith(SugiyamaLayoutConfig value,
          $Res Function(SugiyamaLayoutConfig) then) =
      _$SugiyamaLayoutConfigCopyWithImpl<$Res, SugiyamaLayoutConfig>;
  @useResult
  $Res call(
      {double groupHorizontalPadding,
      double groupVerticalPadding,
      double nodeMarginX,
      double nodeMarginY,
      String rankDir,
      String ranker,
      @SizeConverter() Size emptyGroupSize,
      bool compactTop,
      bool compactBottom,
      bool compactLeft,
      bool compactRight});
}

/// @nodoc
class _$SugiyamaLayoutConfigCopyWithImpl<$Res,
        $Val extends SugiyamaLayoutConfig>
    implements $SugiyamaLayoutConfigCopyWith<$Res> {
  _$SugiyamaLayoutConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupHorizontalPadding = null,
    Object? groupVerticalPadding = null,
    Object? nodeMarginX = null,
    Object? nodeMarginY = null,
    Object? rankDir = null,
    Object? ranker = null,
    Object? emptyGroupSize = null,
    Object? compactTop = null,
    Object? compactBottom = null,
    Object? compactLeft = null,
    Object? compactRight = null,
  }) {
    return _then(_value.copyWith(
      groupHorizontalPadding: null == groupHorizontalPadding
          ? _value.groupHorizontalPadding
          : groupHorizontalPadding // ignore: cast_nullable_to_non_nullable
              as double,
      groupVerticalPadding: null == groupVerticalPadding
          ? _value.groupVerticalPadding
          : groupVerticalPadding // ignore: cast_nullable_to_non_nullable
              as double,
      nodeMarginX: null == nodeMarginX
          ? _value.nodeMarginX
          : nodeMarginX // ignore: cast_nullable_to_non_nullable
              as double,
      nodeMarginY: null == nodeMarginY
          ? _value.nodeMarginY
          : nodeMarginY // ignore: cast_nullable_to_non_nullable
              as double,
      rankDir: null == rankDir
          ? _value.rankDir
          : rankDir // ignore: cast_nullable_to_non_nullable
              as String,
      ranker: null == ranker
          ? _value.ranker
          : ranker // ignore: cast_nullable_to_non_nullable
              as String,
      emptyGroupSize: null == emptyGroupSize
          ? _value.emptyGroupSize
          : emptyGroupSize // ignore: cast_nullable_to_non_nullable
              as Size,
      compactTop: null == compactTop
          ? _value.compactTop
          : compactTop // ignore: cast_nullable_to_non_nullable
              as bool,
      compactBottom: null == compactBottom
          ? _value.compactBottom
          : compactBottom // ignore: cast_nullable_to_non_nullable
              as bool,
      compactLeft: null == compactLeft
          ? _value.compactLeft
          : compactLeft // ignore: cast_nullable_to_non_nullable
              as bool,
      compactRight: null == compactRight
          ? _value.compactRight
          : compactRight // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SugiyamaLayoutConfigImplCopyWith<$Res>
    implements $SugiyamaLayoutConfigCopyWith<$Res> {
  factory _$$SugiyamaLayoutConfigImplCopyWith(_$SugiyamaLayoutConfigImpl value,
          $Res Function(_$SugiyamaLayoutConfigImpl) then) =
      __$$SugiyamaLayoutConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double groupHorizontalPadding,
      double groupVerticalPadding,
      double nodeMarginX,
      double nodeMarginY,
      String rankDir,
      String ranker,
      @SizeConverter() Size emptyGroupSize,
      bool compactTop,
      bool compactBottom,
      bool compactLeft,
      bool compactRight});
}

/// @nodoc
class __$$SugiyamaLayoutConfigImplCopyWithImpl<$Res>
    extends _$SugiyamaLayoutConfigCopyWithImpl<$Res, _$SugiyamaLayoutConfigImpl>
    implements _$$SugiyamaLayoutConfigImplCopyWith<$Res> {
  __$$SugiyamaLayoutConfigImplCopyWithImpl(_$SugiyamaLayoutConfigImpl _value,
      $Res Function(_$SugiyamaLayoutConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupHorizontalPadding = null,
    Object? groupVerticalPadding = null,
    Object? nodeMarginX = null,
    Object? nodeMarginY = null,
    Object? rankDir = null,
    Object? ranker = null,
    Object? emptyGroupSize = null,
    Object? compactTop = null,
    Object? compactBottom = null,
    Object? compactLeft = null,
    Object? compactRight = null,
  }) {
    return _then(_$SugiyamaLayoutConfigImpl(
      groupHorizontalPadding: null == groupHorizontalPadding
          ? _value.groupHorizontalPadding
          : groupHorizontalPadding // ignore: cast_nullable_to_non_nullable
              as double,
      groupVerticalPadding: null == groupVerticalPadding
          ? _value.groupVerticalPadding
          : groupVerticalPadding // ignore: cast_nullable_to_non_nullable
              as double,
      nodeMarginX: null == nodeMarginX
          ? _value.nodeMarginX
          : nodeMarginX // ignore: cast_nullable_to_non_nullable
              as double,
      nodeMarginY: null == nodeMarginY
          ? _value.nodeMarginY
          : nodeMarginY // ignore: cast_nullable_to_non_nullable
              as double,
      rankDir: null == rankDir
          ? _value.rankDir
          : rankDir // ignore: cast_nullable_to_non_nullable
              as String,
      ranker: null == ranker
          ? _value.ranker
          : ranker // ignore: cast_nullable_to_non_nullable
              as String,
      emptyGroupSize: null == emptyGroupSize
          ? _value.emptyGroupSize
          : emptyGroupSize // ignore: cast_nullable_to_non_nullable
              as Size,
      compactTop: null == compactTop
          ? _value.compactTop
          : compactTop // ignore: cast_nullable_to_non_nullable
              as bool,
      compactBottom: null == compactBottom
          ? _value.compactBottom
          : compactBottom // ignore: cast_nullable_to_non_nullable
              as bool,
      compactLeft: null == compactLeft
          ? _value.compactLeft
          : compactLeft // ignore: cast_nullable_to_non_nullable
              as bool,
      compactRight: null == compactRight
          ? _value.compactRight
          : compactRight // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SugiyamaLayoutConfigImpl extends _SugiyamaLayoutConfig {
  const _$SugiyamaLayoutConfigImpl(
      {this.groupHorizontalPadding = 0.0,
      this.groupVerticalPadding = 0.0,
      this.nodeMarginX = 20.0,
      this.nodeMarginY = 20.0,
      this.rankDir = 'TB',
      this.ranker = 'network-simplex',
      @SizeConverter() this.emptyGroupSize = const Size(80, 60),
      this.compactTop = true,
      this.compactBottom = false,
      this.compactLeft = false,
      this.compactRight = false})
      : super._();

  factory _$SugiyamaLayoutConfigImpl.fromJson(Map<String, dynamic> json) =>
      _$$SugiyamaLayoutConfigImplFromJson(json);

  @override
  @JsonKey()
  final double groupHorizontalPadding;
  @override
  @JsonKey()
  final double groupVerticalPadding;
  @override
  @JsonKey()
  final double nodeMarginX;
  @override
  @JsonKey()
  final double nodeMarginY;
  @override
  @JsonKey()
  final String rankDir;
  @override
  @JsonKey()
  final String ranker;
  @override
  @JsonKey()
  @SizeConverter()
  final Size emptyGroupSize;
  @override
  @JsonKey()
  final bool compactTop;
  @override
  @JsonKey()
  final bool compactBottom;
  @override
  @JsonKey()
  final bool compactLeft;
  @override
  @JsonKey()
  final bool compactRight;

  @override
  String toString() {
    return 'SugiyamaLayoutConfig(groupHorizontalPadding: $groupHorizontalPadding, groupVerticalPadding: $groupVerticalPadding, nodeMarginX: $nodeMarginX, nodeMarginY: $nodeMarginY, rankDir: $rankDir, ranker: $ranker, emptyGroupSize: $emptyGroupSize, compactTop: $compactTop, compactBottom: $compactBottom, compactLeft: $compactLeft, compactRight: $compactRight)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SugiyamaLayoutConfigImpl &&
            (identical(other.groupHorizontalPadding, groupHorizontalPadding) ||
                other.groupHorizontalPadding == groupHorizontalPadding) &&
            (identical(other.groupVerticalPadding, groupVerticalPadding) ||
                other.groupVerticalPadding == groupVerticalPadding) &&
            (identical(other.nodeMarginX, nodeMarginX) ||
                other.nodeMarginX == nodeMarginX) &&
            (identical(other.nodeMarginY, nodeMarginY) ||
                other.nodeMarginY == nodeMarginY) &&
            (identical(other.rankDir, rankDir) || other.rankDir == rankDir) &&
            (identical(other.ranker, ranker) || other.ranker == ranker) &&
            (identical(other.emptyGroupSize, emptyGroupSize) ||
                other.emptyGroupSize == emptyGroupSize) &&
            (identical(other.compactTop, compactTop) ||
                other.compactTop == compactTop) &&
            (identical(other.compactBottom, compactBottom) ||
                other.compactBottom == compactBottom) &&
            (identical(other.compactLeft, compactLeft) ||
                other.compactLeft == compactLeft) &&
            (identical(other.compactRight, compactRight) ||
                other.compactRight == compactRight));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      groupHorizontalPadding,
      groupVerticalPadding,
      nodeMarginX,
      nodeMarginY,
      rankDir,
      ranker,
      emptyGroupSize,
      compactTop,
      compactBottom,
      compactLeft,
      compactRight);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SugiyamaLayoutConfigImplCopyWith<_$SugiyamaLayoutConfigImpl>
      get copyWith =>
          __$$SugiyamaLayoutConfigImplCopyWithImpl<_$SugiyamaLayoutConfigImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SugiyamaLayoutConfigImplToJson(
      this,
    );
  }
}

abstract class _SugiyamaLayoutConfig extends SugiyamaLayoutConfig {
  const factory _SugiyamaLayoutConfig(
      {final double groupHorizontalPadding,
      final double groupVerticalPadding,
      final double nodeMarginX,
      final double nodeMarginY,
      final String rankDir,
      final String ranker,
      @SizeConverter() final Size emptyGroupSize,
      final bool compactTop,
      final bool compactBottom,
      final bool compactLeft,
      final bool compactRight}) = _$SugiyamaLayoutConfigImpl;
  const _SugiyamaLayoutConfig._() : super._();

  factory _SugiyamaLayoutConfig.fromJson(Map<String, dynamic> json) =
      _$SugiyamaLayoutConfigImpl.fromJson;

  @override
  double get groupHorizontalPadding;
  @override
  double get groupVerticalPadding;
  @override
  double get nodeMarginX;
  @override
  double get nodeMarginY;
  @override
  String get rankDir;
  @override
  String get ranker;
  @override
  @SizeConverter()
  Size get emptyGroupSize;
  @override
  bool get compactTop;
  @override
  bool get compactBottom;
  @override
  bool get compactLeft;
  @override
  bool get compactRight;
  @override
  @JsonKey(ignore: true)
  _$$SugiyamaLayoutConfigImplCopyWith<_$SugiyamaLayoutConfigImpl>
      get copyWith => throw _privateConstructorUsedError;
}
